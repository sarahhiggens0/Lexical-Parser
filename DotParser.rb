# The parser takes as input a stream of tokens and determines whether
# those tokens follow the grammatical structure of Dot.T
# Author:: Sarah Higgens
require_relative "Token"

class DotParser 		
	def initialize(lexer)
		@ID = 1
		@INT = 2
		@STRING = 3
		@LCURLY = 4
		@RCURLY = 5
		@SEMI = 6
		@LBRACK = 7
		@RBRACK = 8
		@ARROW = 9
		@EQUALS = 10
		@DIGRAPH = 11
		@SUBGRAPH = 12
		@COMMA = 13
		@WS = 14
		@EOF = 100
		@BADINPUT = 101
		@lexer = lexer
		@tokens = Array.new
		@counter = 0
		t = @lexer.nextToken
		while Token.EOF != t.type do
			@tokens.push(t)
			t = @lexer.nextToken
		end
	end
	
	# Parses strings in the language generated by the rule:
	# graph -> ( 'GRAPH' | 'DIGRAPH') [id] '{' stmt_list '}'
	def graph	
			if(@tokens[@counter].type == @DIGRAPH )
				puts "Start recognizing a digraph" 
				increment
			end
			if(id)
				increment
			end
			if(@tokens[@counter].type  == @LCURLY)
				stmt_list
			end 
			puts "Finish recognizing a digraph"
	end
	
	# Parses strings in the language generated by the rule:
	# stmt_list -> {stmt ';'}
	def stmt_list 
		increment
		puts "Start recognizing a cluster"
		while(@tokens[@counter].type != @RCURLY)
			stmt 
			increment
		end 
		puts "Finish recognizing a cluster" 
	end
	
	# Parses strings in the language generated by the rule:
	# stmt -> edge_stmt | id '=' id | subgraph
	def stmt
		if(@tokens[@counter].type == @SUBGRAPH)
			increment
			if(@tokens[@counter].type == @ARROW)
				edge_stmt
			else 
				subgraph
			end 
		end
		if(id)
			increment
			if(@tokens[@counter].type == @ARROW)
				edge_stmt
			else 
				puts "Start recognizing a property "
				increment
				increment
				puts "Finish recognizing a property"
			end 
		end 
		if(@tokens[@counter].type == @LCURLY)
			abort( "Error: expecting property, edge or subgraph, but found: {")
		end 
	end 
	
	# Parses strings in the language generated by the rule:
	# edge_stmt -> ( id | subgraph ) edgeRHS [attr_list]
	def edge_stmt
		puts "Start recognizing an edge statement"
		edgeRHS
		if(@tokens[@counter].type == @LBRACK)
			attr_list
		end
		if(@tokens[@counter].type == @SEMI)
			puts "Finish recognizing an edge statement"
		else
			abort( "Error: expecting ; or edge, but found: init")
		end 
	end
	
	# Parses strings in the language generated by the rule:
	# attr_list -> '[' [a_list] ']' 
	def attr_list
		a_list 
	end  

	# Parses strings in the language generated by the rule:
	# a_list -> id ['=' id ] {',' id ['=' id ] }
	def a_list 
		puts "Start recognizing a property"
		increment
		increment
		if(@tokens[@counter].type == @EQUALS)
			increment
		end 
		puts "Finish recognizing a property"
		increment
		while(@tokens[@counter].type == @COMMA)
			puts "Start recognizing a property"
			increment
			increment
			if(@tokens[@counter].type == @EQUALS)
				increment
			end 
			increment
			puts "Finish recognizing a property"
		end 
		increment
	end
	
	# Parses strings in the language generated by the rule:
	# edgeRHS -> edge ( id | subgraph ) {edge ( id | subgraph )}
	def edgeRHS 
		while(@tokens[@counter].type == @ARROW)
			increment
			if(id)
				increment
			else
				subgraph
			end 
		end 
	end
	
	# Parses strings in the language generated by the rule:
	# subgraph -> 'SUBGRAPH' [id] '{' stmt_list '}
	def subgraph 
		puts "Start recognizing a subgraph"
		if(@tokens[@counter].type == @ID || @tokens[@counter].type == @INT || @tokens[@counter].type == @STRING )
				increment
		end
		stmt_list
		puts "Finish recognizing a subgraph"
	end 
	
	# Parses strings in the language generated by the rule:
	# id -> ID | STRING | INT
	def id
		if(@tokens[@counter].type == @ID || @tokens[@counter].type == @INT || @tokens[@counter].type == @STRING )
			return true 
		else 
			return false 
		end 
	end 
	
	# This moves the counter up in the array of terms. 
	# This method was created to improve readabiliy. 
	def increment 
		@counter = @counter + 1
	end 

end 
